import { Component, ViewChild, AfterViewInit } from '@angular/core';
import {
  HttpClient,
  HttpErrorResponse,
  HttpParams,
} from '@angular/common/http';
import { DialogComponent } from '@syncfusion/ej2-angular-popups';
import { ToastComponent } from '@syncfusion/ej2-angular-notifications';
import {
  CommandModel,
  CommandClickEventArgs,
} from '@syncfusion/ej2-angular-grids';
import {
  PoDetailResponse,
  PoHeaderView,
  PoLineView,
  PoListResponse,
  PoStage,
} from 'src/app/core/models/poapprovals/poapprovals_models';

@Component({
  selector: 'app-po-approvals-browser',
  templateUrl: './po-approvals-browser.component.html',
  styleUrls: ['./po-approvals-browser.component.css'],
})
export class PoApprovalsBrowserComponent implements AfterViewInit {
  // ────────────────────── Public state (template-bound) ──────────────────────
  public poRows: PoHeaderView[] = [];

  public detailHeader: PoHeaderView | null = null;
  public lines: PoLineView[] = [];
  public stages: PoStage[] = [];
  public dialogOpen = false;

  // Busy/disabled state during approve/deny
  public decidingAction: 'approve' | 'deny' | null = null;

  // Lock approve/deny after a successful decision (per PO)
  public decisionLocked = false;

  // Highlight stage just decided
  private lastDecision: {
    poNumber: string;
    sequence: number;
    status: 'A' | 'D';
    atMs: number;
  } | null = null;

  // Frontend stage status override (for visual cue when backend finalizes)
  // Keyed by "PO::SEQ"
  private stageStatusOverrides: Record<string, 'A' | 'D'> = {};

  // Highlight duration (ms)
  private readonly stageHighlightMs = 20000;

  // Max length for decision note (DecisionNote column limit)
  public readonly decisionNoteMaxLength = 4000;

  // Command column buttons (used by template)
  public commands: CommandModel[] = [
    {
      type: 'None',
      buttonOption: { content: 'Details', cssClass: 'e-primary cmd-view' },
    },
  ];

  // Docs dialog state (template reads these)
  public currentPoForDocs: PoHeaderView | null = null;
  public notesText: string = '';
  public selectedFiles: File[] = [];

  // Position for docs dialog; updated to sit over the details dialog
  public docDialogPosition: { X: number | string; Y: number | string } = {
    X: 'center',
    Y: 'center',
  };

  // In-memory cache of notes keyed by PO number
  private noteCache: { [poNumber: string]: string } = {};

  // ────────────────────── Private template refs ──────────────────────────────
  @ViewChild('poDialog', { static: false })
  private poDialog?: DialogComponent;

  @ViewChild('docDialog', { static: false })
  private docDialog?: DialogComponent;

  @ViewChild('toast', { static: false })
  private toast?: ToastComponent;

  // ────────────────────── Construction & lifecycle ───────────────────────────
  public constructor(private http: HttpClient) {}

  private userEmail = `${
    JSON.parse(localStorage.getItem('currentUser') as string).networkUsername
  }@itt.com`;

  public ngAfterViewInit(): void {
    if (!this.toast) return;

    // Syncfusion Angular Toast doesn't expose zIndex as an Angular input in some versions,
    // so we set it via TS.
    (this.toast as any).zIndex = 100000;
    this.toast.dataBind?.();
  }

  public ngOnInit(): void {
    const params = new HttpParams()
      .set('page', '1')
      .set('pageSize', '20')
      .set('email', this.userEmail);

    this.http.get<PoListResponse>('/api/po', { params }).subscribe((resp) => {
      const rows = (resp?.rows ?? []).map(this.toHeader);
      this.poRows = rows;
    });
  }

  public onCommandClick(args: CommandClickEventArgs): void {
    const row: any = args.rowData;
    const target = args.target as HTMLElement | null;
    const poNumber: string = row?.poNumber ?? row?.PoNumber ?? '';

    if (target?.classList.contains('cmd-view')) {
      this.loadDetails(poNumber, row);
      return;
    }
    if (target?.classList.contains('cmd-docs')) {
      this.openDocsForRow(row);
      return;
    }
  }

  public onDlgOpen(): void {
    this.dialogOpen = true;
    this.freezePageScroll();
  }

  public onDlgClose(): void {
    this.dialogOpen = false;
    this.unfreezePageScroll();

    // Optional: when dialog closes, clear ephemeral highlight state
    this.lastDecision = null;
  }

  // ────────────────────── Toast helpers ──────────────────────
  private showToast(title: string, content: string, cssClass: string): void {
    this.toast?.show({ title, content, cssClass });
  }

  // ────────────────────── Category label helpers ──────────────────────
  public getCategoryLabel(s: PoStage): string {
    if (s.category === 'I') return 'Indirect';
    if (s.category === 'D') return 'Direct';
    return 'Indirect + Direct';
  }

  // ────────────────────── Stage effective status (UI override) ──────────────────────
  private stageKey(poNumber: string, sequence: number): string {
    return `${poNumber}::${sequence}`;
  }

  public getEffectiveStageStatus(s: PoStage): PoStage['status'] {
    const key = this.stageKey(s.poNumber, s.sequence);
    const ov = this.stageStatusOverrides[key];
    return (ov ?? s.status) as PoStage['status'];
  }

  private setStageOverride(poNumber: string, sequence: number, status: 'A' | 'D'): void {
    this.stageStatusOverrides[this.stageKey(poNumber, sequence)] = status;
  }

  private clearStageOverrides(): void {
    this.stageStatusOverrides = {};
  }

  // ────────────────────── Effective header status (fix for W staying yellow) ──────────────────────
  public getEffectiveHeaderStatus(): 'W' | 'A' | 'D' {
    const h = this.detailHeader;
    if (!h) return 'W';

    // If backend already finalized the header, trust it.
    if (h.status === 'A' || h.status === 'D') return h.status;

    // If header says W but stages clearly indicate final state, infer for UI.
    if (!this.stages || this.stages.length === 0) return h.status;

    const effectiveStatuses = this.stages.map((s) => this.getEffectiveStageStatus(s));

    // Any denied stage => denied PO (visual cue)
    if (effectiveStatuses.some((st) => st === 'D')) return 'D';

    // Fully done when no pending stages remain and all are A or S
    const hasPending = effectiveStatuses.some((st) => st === 'P');
    const allDone = effectiveStatuses.every((st) => st === 'A' || st === 'S');

    if (!hasPending && allDone) return 'A';

    return h.status; // usually W
  }

  // ────────────────────── Stage highlight helpers ──────────────────────
  public isStageJustDecided(s: PoStage): boolean {
    if (!this.lastDecision) return false;
    if (s.poNumber !== this.lastDecision.poNumber) return false;
    if (s.sequence !== this.lastDecision.sequence) return false;

    const age = Date.now() - this.lastDecision.atMs;
    return age >= 0 && age <= this.stageHighlightMs;
  }

  public getStageRowClasses(s: PoStage): Record<string, boolean> {
    const is = this.isStageJustDecided(s);
    const st = this.lastDecision?.status ?? null;

    return {
      'stage-just-approved': is && st === 'A',
      'stage-just-denied': is && st === 'D',
    };
  }

  private markStageJustDecided(
    poNumber: string,
    sequence: number,
    status: 'A' | 'D'
  ): void {
    this.lastDecision = { poNumber, sequence, status, atMs: Date.now() };

    window.setTimeout(() => {
      if (!this.lastDecision) return;
      const age = Date.now() - this.lastDecision.atMs;
      if (age > this.stageHighlightMs) this.lastDecision = null;
    }, this.stageHighlightMs + 200);
  }

  // ────────────────────── Docs dialog helpers ──────────────────────
  public openDocsForRow(row: any): void {
    const header = this.toHeader(row ?? {});
    this.currentPoForDocs = header;

    const poNumber = header.poNumber;
    this.notesText = this.noteCache[poNumber] ?? '';
    this.selectedFiles = [];

    this.docDialog?.show();
  }

  public openDocsFromDetail(): void {
    if (!this.detailHeader) return;

    this.currentPoForDocs = this.detailHeader;
    const poNumber = this.detailHeader.poNumber;

    this.notesText = this.noteCache[poNumber] ?? '';
    this.selectedFiles = [];

    this.docDialog?.show();
  }

  private positionDocsOverDetails(): void {
    if (!this.poDialog) return;
    const hostElem = this.poDialog.element as HTMLElement | null;
    if (!hostElem) return;

    const rect = hostElem.getBoundingClientRect();
    const x = rect.left + rect.width * 0.15;
    const y = rect.top + rect.height * 0.1;

    this.docDialogPosition = { X: x, Y: y };
  }

  public onDocDlgOpen(): void {
    this.onDlgOpen();
    this.positionDocsOverDetails();
  }

  public onDocDlgClose(): void {
    this.onDlgClose();
    this.currentPoForDocs = null;
    this.notesText = '';
    this.selectedFiles = [];
  }

  public onNotesInput(value: string): void {
    const trimmed = (value ?? '').slice(0, this.decisionNoteMaxLength);
    this.notesText = trimmed;

    const poNumber =
      this.currentPoForDocs?.poNumber ?? this.detailHeader?.poNumber ?? null;
    if (poNumber) {
      this.noteCache[poNumber] = trimmed;
    }
  }

  public onFilesSelected(args: any): void {
    const list: File[] = Array.from(
      (args?.event?.target?.files ?? []) as FileList
    );
    this.selectedFiles = list;
  }

  public removeSelectedFile(idx: number): void {
    this.selectedFiles.splice(idx, 1);
    this.selectedFiles = [...this.selectedFiles];
  }

  private showHttpError(err: any): void {
    this.decidingAction = null;

    let msg = 'Unexpected error.';
    if (err instanceof HttpErrorResponse) {
      const e = err;
      const pd = (e.error || {}) as any;
      if (pd && (pd.title || pd.detail)) {
        msg = `${pd.title ?? 'Error'}${pd.detail ? `: ${pd.detail}` : ''}`;
      } else if (typeof e.error === 'string') {
        msg = e.error;
      } else if (e.message) {
        msg = `${e.status || ''} ${e.statusText || ''} ${e.message}`.trim();
      }
    } else if (typeof err === 'string') {
      msg = err;
    } else if (err && err.message) {
      msg = err.message;
    }
    alert(msg);
  }

  public findMyPendingSequence(): number | null {
    const s = this.stages.find((x) => x.status === 'P');
    return s ? s.sequence : null;
  }

  public approve(): void {
    if (!this.detailHeader) return;
    if (this.decidingAction) return;
    if (this.decisionLocked) return;

    const seq = this.findMyPendingSequence();
    if (seq == null) {
      alert('No pending stage for you on this PO.');
      return;
    }

    const poNumber = this.detailHeader.poNumber;
    const noteSource =
      this.noteCache[poNumber] != null ? this.noteCache[poNumber] : this.notesText;
    const note = (noteSource ?? '').slice(0, this.decisionNoteMaxLength);

    this.decidingAction = 'approve';

    const url = `/api/po/${encodeURIComponent(poNumber)}/stages/${seq}/approve`;
    const sub = this.http
      .post(url, { userId: this.userEmail, note })
      .subscribe({
        next: () => {
          delete this.noteCache[poNumber];
          this.notesText = '';

          this.setStageOverride(poNumber, seq, 'A');
          this.markStageJustDecided(poNumber, seq, 'A');
          this.decisionLocked = true;

          this.showToast('Approved', `PO ${poNumber} stage ${seq} approved.`, 'toast-ok');

          this.loadDetails(poNumber);
          this.ngOnInit();
        },
        error: (err) => this.showHttpError(err),
      });

    sub.add(() => {
      this.decidingAction = null;
    });
  }

  public deny(): void {
    if (!this.detailHeader) return;
    if (this.decidingAction) return;
    if (this.decisionLocked) return;

    const seq = this.findMyPendingSequence();
    if (seq == null) {
      alert('No pending stage for you on this PO.');
      return;
    }

    const poNumber = this.detailHeader.poNumber;
    const noteSource =
      this.noteCache[poNumber] != null ? this.noteCache[poNumber] : this.notesText;
    const note = (noteSource ?? '').slice(0, this.decisionNoteMaxLength);

    this.decidingAction = 'deny';

    const url = `/api/po/${encodeURIComponent(poNumber)}/stages/${seq}/deny`;
    const sub = this.http
      .post(url, { userId: this.userEmail, note })
      .subscribe({
        next: () => {
          delete this.noteCache[poNumber];
          this.notesText = '';

          this.setStageOverride(poNumber, seq, 'D');
          this.markStageJustDecided(poNumber, seq, 'D');
          this.decisionLocked = true;

          this.showToast('Denied', `PO ${poNumber} stage ${seq} denied.`, 'toast-bad');

          this.loadDetails(poNumber);
          this.ngOnInit();
        },
        error: (err) => this.showHttpError(err),
      });

    sub.add(() => {
      this.decidingAction = null;
    });
  }

  // ────────────────────── mapping & API ─────────────────────
  private toHeader = (h: any): PoHeaderView => ({
    poNumber: h.poNumber ?? h.PoNumber ?? '',
    poDate: h.poDate ?? h.PoDate,
    vendorName: h.vendorName ?? h.VendorName,
    buyerName: h.buyerName ?? h.BuyerName,
    houseCode: h.houseCode ?? h.HouseCode,
    directAmount: h.directAmount ?? h.DirectAmount ?? 0,
    indirectAmount: h.indirectAmount ?? h.IndirectAmount ?? 0,
    totalAmount:
      h.totalAmount ??
      h.TotalAmount ??
      (h.directAmount ?? h.DirectAmount ?? 0) +
        (h.indirectAmount ?? h.IndirectAmount ?? 0),
    status: (h.status ?? h.Status ?? 'W') as 'W' | 'A' | 'D',
    isActive: (h.isActive ?? h.IsActive ?? true) as boolean,
    createdAtUtc: h.createdAtUtc ?? h.CreatedAtUtc,
    activeLineCount: h.activeLineCount ?? h.ActiveLineCount ?? 0,
  });

  private toLine = (l: any): PoLineView => ({
    poNumber: l.poNumber ?? l.PoNumber ?? '',
    lineNumber: l.lineNumber ?? l.LineNumber ?? 0,
    itemNumber: l.itemNumber ?? l.ItemNumber ?? '',
    itemDescription: l.itemDescription ?? l.ItemDescription,
    specialDescription: l.specialDescription ?? l.SpecialDescription,
    quantityOrdered: l.quantityOrdered ?? l.QuantityOrdered,
    orderUom: l.orderUom ?? l.OrderUom,
    unitCost: l.unitCost ?? l.UnitCost,
    extendedCost: l.extendedCost ?? l.ExtendedCost,
    requiredDate: l.requiredDate ?? l.RequiredDate,
    glAccount: l.glAccount ?? l.GlAccount,
    isActive: (l.isActive ?? l.IsActive ?? true) as boolean,
  });

  private toStage = (s: any): PoStage => ({
    poNumber: s.poNumber ?? s.PoNumber ?? '',
    sequence: s.sequence ?? s.Sequence ?? 0,
    roleCode: s.roleCode ?? s.RoleCode ?? '',
    approverUserId: s.approverUserId ?? s.ApproverUserId,
    category: (s.category ?? s.Category ?? null) as 'I' | 'D' | null,
    thresholdFrom: s.thresholdFrom ?? s.ThresholdFrom,
    thresholdTo: s.thresholdTo ?? s.ThresholdTo,
    status: (s.status ?? s.Status ?? 'P') as 'P' | 'A' | 'D' | 'S',
    decidedAtUtc: s.decidedAtUtc ?? s.DecidedAtUtc,
  });

  private loadDetails(poNumber: string, fallbackRow?: any): void {
    if (!poNumber) return;

    // If switching to a new PO, reset per-PO UI state
    const currentPo = this.detailHeader?.poNumber ?? null;
    if (!currentPo || currentPo !== poNumber) {
      this.decisionLocked = false;
      this.lastDecision = null;
      this.clearStageOverrides();
    }

    this.http
      .get<PoDetailResponse>(`/api/po/${encodeURIComponent(poNumber)}`)
      .subscribe((d) => {
        this.detailHeader = this.toHeader(d?.header ?? fallbackRow ?? {});
        this.lines = (d?.lines ?? []).map(this.toLine);
        this.stages = (d?.stages ?? []).map(this.toStage);
        this.poDialog?.show();
      });
  }

  // ────────────────────── page scroll locking ───────────────────────
  private scrollY = 0;
  private bodyStyleBackup: Partial<CSSStyleDeclaration> = {};
  private lockDepth = 0;

  private freezePageScroll(): void {
    if (this.lockDepth++ > 0) return;
    if (typeof window === 'undefined' || typeof document === 'undefined') return;

    this.scrollY = window.scrollY || window.pageYOffset || 0;
    const b = document.body;
    this.bodyStyleBackup = {
      position: b.style.position,
      overflow: b.style.overflow,
      width: b.style.width,
      top: b.style.top,
      left: b.style.left,
      right: b.style.right,
    };
    b.style.position = 'fixed';
    b.style.overflow = 'hidden';
    b.style.width = '100%';
    b.style.top = `-${this.scrollY}px`;
    b.style.left = '0';
    b.style.right = '0';
  }

  private unfreezePageScroll(): void {
    if (--this.lockDepth > 0) return;
    if (typeof window === 'undefined' || typeof document === 'undefined') return;

    const b = document.body;
    b.style.position = this.bodyStyleBackup.position ?? '';
    b.style.overflow = this.bodyStyleBackup.overflow ?? '';
    b.style.width = this.bodyStyleBackup.width ?? '';
    b.style.top = this.bodyStyleBackup.top ?? '';
    b.style.left = this.bodyStyleBackup.left ?? '';
    b.style.right = this.bodyStyleBackup.right ?? '';
    window.scrollTo(0, this.scrollY);
  }
}
